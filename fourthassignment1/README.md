# MPA VS SPA

## MPA (다중 페이지 어플리케이션)

멀티페이지 어플리케이션은 전통적인 방법으로 서버에 페이지를 요청하면 서버에서 해당 html,css ,js 을 응답하고 클라이언트에서는 이를 로드합니다.
장점으로는 검색엔진최적화가 쉽고 단점으로는 개발이 복잡하고, SPA만큼의 부드러운 전환은 할 수 없습니다.

- 장점
  - SEO
- 단점
  - 상대적으로 복잡한 개발
  - 부드럽지 못한 전환

## SPA (싱글 페이지 어플리케이션)

싱글페이지 어플리케이션은 사용하는 동안 페이지 로딩을 필요로 하지 않습니다.
싱글페이지는 페이지 리로드가 필요없기 때문에 MPA보다 부드러운 사용자 경험을 제공합니다.

단점으로는 자바스크립트에 의존적이므로 자바스크립트를 강제로 꺼버리면 사용할 수 없게 되고, 자바스크립트가 실행되야 컨텐츠가 보이므로 SEO(검색엔진최적화)에 문제가 생깁니다.

- 장점
  - 부드러운 전환
  - 개발 속도
- 단점
  - SEO
  - 자바스크립트 필수

---

# Virtual DOM

## Virtual DOM은 왜 필요할까?

DOM 조작은 모던, 상호작용하는 웹에서 핵심입니다. 하지만, DOM 조작은 많은 자바스크립트 작업보다 훨신 느립니다.
모던 자바스크립트 프레임워크들은 DOM을 그들이 해야하는 것 보다 더 많이 조작을 하는데, 이것은 DOM 조작을 더욱 느리게 합니다.

예를 들어, 당신이 10개의 아이템을 포함하고 있는 리스트를 가지고 있다고 합시다. 당신이 첫번째 아이템을 변경한다면, 많은 자바스크립트 프레임워크는 전체 리스트를 다시 만들 것 입니다.
첫번째 아이템만 변경하면 되는데, 전체 리스트를 다시 만들다니, 필요한 것보다 일을 10배 더 하는 것 이죠.
하나의 아이템만 변경됬지만, 다른 아이템들도 전의 상태와 정확히 동일하게 rebuild 됩니다.

이런 리스트를 다시 build하는 것은 웹브라우저에서는 큰 문제가 아닐지도 모릅니다. 하지만 모던 웹사이트는 엄청나게 많이 DOM을 조작합니다. 이런 비효율적인 DOM변경은 큰 문자가 될 수 있습니다.

이런 문제를 해결하기 위해, React는 virtual DOM라는 개념을 도입했습니다.

## Virtual DOM이란?

React의 Virtual Dom은 가상의 DOM에 번경사항을 먼저 저장하고 ReactDOM 라이브러리를 통해 실제 DOM과 동기화를 합니다.
React는 모든 DOM 객체를 virtual DOM 객체에 대응시킵니다. virtual DOM은 실제 DOM의 lightweight 버전입니다.
DOM을 조작하는 것은 느리지만 virtual DOM을 조작하는 것은 훨신 빠릅니다. 왜냐하면 virtual DOM은 화면에 아무것도 그리지 않기 때문입니다.
Virtual DOM을 조작하는 것은 설계도(청사진)을 수정하는 것에 비유할 수 있고, 실제 DOM을 조작하는 것은 진짜 집에서 방을 움직이는 것에 비유할 수 있습니다.

## How it helps?

jsx로 만들어진 element를 렌더링하면, 모든 virtual DOM 객체가 업데이트됩니다.

이건 굉장히 비효율적으로 들릴 수 있지만, virtual DOM은 굉장히 빨리 업데이트를 할 수 있기 때문에 여기에 드는 비용은 의미가 없습니다.

한번 virtual DOM이 업데이트되면, React는 업데이트 된 virtual DOM과 바로 직전 virtual DOM의 snapshot을 비교합니다.

virtual DOM을 업데이트 되기 전의 버전과 비교함으로, 리엑트는 정확히 어떤 virtual DOM 객체들이 변경되었는지 알아냅니다. 이 프로세스는 "diffing"이라고 불립니다.

일단 어떤 virtual DOM 객체가 변경되었는지 알아냈다면, 리엑트는 그 객체들만 실제 DOM에 업데이트합니다.

앞의 예시에서는, React는 똑똑하기 때문에 나머지의 아이템들은 다시 build 하지 않고 선택한 아이템만 변경합니다.

이것은 굉장히 큰 차이를 만듭니다.

### React는 DOM의 필요한 부분만 변경할 수 있습니다. React의 성능에 대한 호평은 이 혁명에서 오는 부분이 크게 차지하고 있습니다.

사용자가 React를 통해 DOM을 조작하려고 할 때 일어나는 일을 요약하자면,

1. 전체 virtual DOM이 업데이트 된다.
2. 업데이트 된 virtual DOM은 이전 virutal DOM과 비교한다. React는 어떤 virtual DOM 객체가 변경됬는지 알아낸다.
3. 변경된 virtual DOM 객체만 실제 DOM에 업데이트 한다.
4. 업데이트된 실제 DOM은 screen을 바뀌게 한다.

---

# 브라우저의 렌더링 과정

브라우저에는 자바스크립트 엔진(크롬의 경우 V8엔진)말고도 렌더링 엔진이라는 것이 있습니다.
렌더링 엔진의 역할은 요청받은 내용을 브라우저 화면에 나타내는 일입니다.

브라우저마다 사용하는 렌더링 엔진이 달라 브라우저마다 다르게 그려지는 크로스 브라우징 이슈가 발생하게 됩니다.

대표적으로 크롬은 Blink, 사파리는 Webkit, 파이어폭스는 Gecko를 사용합니다.

렌더링 엔진마다 다를 수 있지만 과정을 크게 나누어 보자면

1. HTML,CSS,JS 로드.
2. HTML 파싱, CSS 파싱.
3. 파싱된 HTML을 가지고 DOM 트리를 구성, 파싱된 CSS를 가지고 CSSOM 트리 구성.
4. DOM 트리와 CSSOM 트리를 결합하여 render 트리 구성.
5. render 트리를 가지고 painting을 하여 화면에 표시.

---

# 클래스형 컴포넌트 vs 함수형 컴포넌트

### 함수형 컴포넌트

- 함수형 컴포넌트는 인자로 props를 받고 React element를 return 하는 자바스크립트 함수입니다.
- 함수형 컴포넌트는 안에 render 메소드를 사용하지 않습니다.
- 함수형 컴포넌트는 Stateless 컴포넌트라고도 알려져있는데 왜냐하면 함수형 컴포넌트는 data를 받아서 display하는, UI를 rendering하는데에 중점적이기 때문입니다.
- 함수형 컴포넌트에서 lifecycle 메소드(componentDidMount 등)은 사용할 수 없습니다.
- Hooks는 함수형 컴포넌트를 stateful하는데 쉽게 사용할 수 있습니다.
- 생성자가 사용되지 않습니다.

### 클래스 컴포넌트

- 클래스 컴포넌트를 정의하기 위해서는 React을 extend 됩니다. 이 컴포넌트는 React element를 return하기 위해 render메소드를 사용합니다.
- JSX를 return하기 위해 render메소드를 사용해야됩니다.
- logic과 state를 가지고 있어서 stateful 컴포넌트라고도 불립니다.
- lifecycle메소드를 클래스 컴포넌트 안에서 사용할 수 있습니다.
- hooks들을 구연하기 위해서는 다른 syntax가 필요합니다.
- state를 저장하기 위해 Constructor가 필요합니다.

## 함수형 컴포넌트를 권장하는 이유

- react hooks들은 함수형 컴포넌트에서만 사용할 수 있습니다.
- 함수형 컴포넌트는 state와 likecycle-hooks가 없는 plain 자바스크립트 함수이기 때문에 코드를 읽고 테스트 하기 훨신 편합니다.
- 코드의 양을 줄일 수 있습니다.
- container와 presentatinal 컴포넌트를 분리하기 쉽습니다. hooks를 사용못하는 클래스 컴포넌트에서는 고려해야할 것이 많기 때문입니다.
- React team에서 미래의 react version에서 함수형 컴포넌트를 사용하면 성능향상이 있을 수 있다고 언급했습니다!

# 렌더링? 마운트?

### 마운트

DOM에 삽입되었을 때 마운트라고 말한다.
ReactDOM.render 함수를 사용해서 DOM에 마운트 할 수 있다.

### 렌더링

마운트 되었거나 , props의 값이 바뀌거나, 부모 컴포넌트가 재렌더링 되거나(useMemo를 사용안했을 때), 컴포넌트의 state가 바뀌었을 때 재렌더링 된다.
